# Типизация

## Общее

[Type.py](Type.py)


Поддерживаются следующие типы выражений:
 * `NoneType` - тип print/let
 * bool - `Bool`
 * int - `Int`
 * Строка - `String`
 * Типизированное множество - `Set<T>`
 * Конечный автомат - `FA<T>`. `T` - тип вершины.
 * Кортежи `Tuple<T1, ...>`
 * Лямбды `Lambda<[Arg1, ...] -> Val>`

Тип выражений вычисляется.
 * `print <expression>` - всегда обладает типом NoneType, но тип `<expression>` всё равно вычисляется
 * `let <pattern> = <expression>` позволяет определить одну или несколько типизированных переменных.
   * Если `<pattern>` это просто имя переменной, то тип этой переменной будет совпадать с типом выражения
   * Если `<pattern>` это полноценный паттерн, то `<expression>` должен быть кортежем сходной структуры

Есть несколько конструкций, которые производят значения определённого типа:
 * Строчные литералы: `"Hello, world"` **::** `String`
 * Целочисленные литералы: `123` **::** `Int`
 * Целочисленные множества
   * `{ }` **::** `Set<Int>` - пустое множество
   * `{ 1, 2, 5, 8 }` **::** `Set<Int>` - множество состоящее из указанных значений
   * `{ 1 .. 5 }`  **::** `Set<Int>` - множество состоящее из значений в указанном интервале
     * То же самое что и `{ 1, 2, 3, 4, 5 }`.
   * В языке есть только выражение для целочисленных множеств и использовать в них можно только числовые литералы

У кортежей чуть более сложная производящая конструкция:
 * Записывается в квадратных скобках, имеет хотя бы один элемент
   * `[1]`, `[2, 3]` - валидные кортежи, `[]`, `1, 2` - невалидные
 * Кортеж может состоять только из _значений_, но не выражений
   * Это значит его составляющими могут быть литералы строк и целых чисел, целочисленные множества и другие кортежи
   * Кортеж на уровне типов может содержать в себе результаты любых вычислений, просто синтаксис языка не
     позволяет строить его из выражений, чтобы быть проще

В языке есть ляюбда-функции: Синтаксис: `\ <pattern> -> <expression>`
 * Вычисление типа `<expression>` опирается на то какого типа переменные в `<pattern>`
   Тип для паттерна берётся из внешнего выражения `map` или `filter`, подробнее позже

## Выражения

Выражение может быть:
 * Именем переменной - принимает тип переменной
 * Значением - принимает тип значения
 * `set starts of <expr1> as <expr2>`
   `set finals of <expr1> as <expr2>`
   * `expr1` - Должен быть `FA<T>`, `expr2` - `Set<T>`, где `T` один и тот же тип.
   * Это выражение принимает тип `FA<T>`
 * `add <expr1> as starts of <expr2>`
    `add <expr1> as starts of <expr2>`
   * `expr1` - `Set<T>`, `expr2` - `FA<T>`
   * выражение `FA<T>`
 * `get_starts of <expr1>`
   `get_finals of <expr1>`
   `get_reachable of <expr1>`
   `get_vertices of <expr1>`
   * `expr1` - `FA<T>`
   * выражение принимает тип `Set<T>`
 * `get_edges of <expr>`
   * `expr` - `FA<T>`
   * выражение принимает тип `Set<Tuple<T, String, T>>`
 * `get_labels of <expr>`
   * `expr` - `FA<T>`
   * выражение принимает тип `Set<String>`
 * `map <expr> with <lambda>`
    * Здесь `expr` должно быть типа `Set<T>` или `Tuple<T, T, ...>`.
      Паттерн в данном случае будет matched с типом `T`. Если это произойдёт неуспешно, будет ошибка типизации.
      `lambda` обладает типом `Lambda<<T> -> U>`
    * Выражение принимает тип `Set<U>` (даже если на входе был кортеж)
 * `filter <expr> with <lambda>`
    * Здесь `expr` должно быть типа `Set<T>` или `Tuple<T, T, ...>`.
      Паттерн в данном случае будет matched с типом `T`. Если это произойдёт неуспешно, будет ошибка типизации.
      `lambda` обладает типом `Lambda<<T> -> Bool>`
    * Выражение принимает тип `Set<T>` (даже если на входе был кортеж)
 * `load <name>`, `name` - или строчный литерал, или имя переменной типизированной как String \
    Выражение принимает тип `FA<Int>`
 * `<expr> & <expr>`
   * `expr` могут принимать тип `FA<Int>` и `String` если их типы не равны друг-другу,
      * тогда выражение принимает тип `FA<Int>`
   * `expr` могут принимать одинаковый тип `FA<T>`,
      * тогда выражение принимает тип `FA<Tuple<T, T>>`
 * `<expr> ++ <expr>`, `<expr> | <expr>`
   * `expr` могут принимать тип `String`,
       * тогда выражение принимает тип `String`
   * `expr` могут принимать тип `FA<Int>` и `String` если их типы не равны друг-другу,
       * тогда выражение принимает тип `FA<Int>`
   * `expr` могут принимать одинаковый тип `FA<T>`,
      * тогда выражение принимает тип `FA<T>`
 * `<expr>*`
   * `expr` должен принимать тип `FA<T>`
   * выражение принимает тип `FA<T>`
 * `<expr1> in <expr2>`
   * `expr2` принимает тип `T` и `expr1` принимает тип `Tuple<T>` или `Set<T>`
   * выражение принимает тип `Bool`
 * `( <expr> )`
   * `expr` принимает любой тип `T`
   * выражение принимает этот же тип `T`
